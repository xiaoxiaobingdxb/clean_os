# 从实模式到保护模式
## 实模式
实模式就是从bios加载第一个扇区开始执行的操作系统代码，在这种模式下默认使用16位寄存器使用20根地址总线，寻址方式为`addr=ds<<4 + offset`，这样寻址的原因是寄存器只有16位，但地址总线有20位，为了能让16位的寄存器使用20位的地址总线，只能用两个寄存器来计算出20位的地址，因此实模式可访问内存大小为2^20=1Mb。

实模式还可以直接使用bios的中断来接收事件或控制各种硬件。在实模式下最经典的就是8086，实模式下通过直接控制段寄存器来访问代码的数据，这个时候的数据和代码其实没有本质区别。

实模式下其实可以使用更多位的寄存器，比如x86_64的寄存器可以使用超过16位的寄存器。并且实际上可以通过直接寻址的方式访问大于1M的内存，例如1M内存的地址最大是0xffff，如果使用直接寻址的方式去访问0x10000也是能够访问的。

由于寄存器只有16位，也就是最多只支持64K大小，因此ip能够连续访问的代码或使用bx/bp/si/di能够访问的数据最多只有64K，如果想要访问超过64K的连续代码或数据，则需要再控制段寄存器，这样也会导致程序变得复杂。

## 保护模式
实模式下的内存访问是直接通过寄存器控制的，如果多个程序并行，很可能会导致多个程序相互修改内存，更为可怕的是可能有些程序会把其他程序的代码段当成数据段来访问，这样可能会导致程序的执行错乱。同时，实模式默认只支持1M内存的访问，这点内存在现代操作系统上是远远不够的。

现代操作系统大多支持多任务，因此多任务的内存管理就显得极其重要。从80286及其之后的cpu开始支持保护模式，在保护模式下，cpu提供了以gdt的方式来进行内存访问，同时也扩大了内存访问的大小，支持的寄存器扩展到32位和64位，因此可寻址的大小也变成了2^32=4Gb和2^64，但其实上32位的地址总线是36位，实际上可用的只有32位，也就是4Gb，64位cpu的地址总线是46位，可用64Tb。详情可见[保护模式wiki](https://zh.wikipedia.org/zh-hans/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F)或[osdev的保护模式介绍](https://wiki.osdev.org/Protected_Mode)

为了在保护模式下也能兼容运行实模式的程序，cpu还提供了一种虚模式。

## 保护模式下的寻址方式——gdt
gdt的全称是global descriptor table，意为全局描述表。由于保护模式不再使用段寄存器的方式来描述段，并且还要保护每个段，因此通过一张表，表内的每行描述段的基址、界限、访问权限级别，这样就可通过表内行的index进行类似于段的访问，行的index又叫段选择子。其中第0行不可使用，因为段选择子的默认值是0，如果没有指定段选择子，就默认访问第0行，也就没有数据了。

gdt每行为8个字节，其中32位储存基址，20位储存段界限，12位储存段属性。但由于历史原因(gdt一行的大小逐渐增加)，这三种储存的位置不是连续的：
1. 0-15:段界限
2. 16-39:段基址
3. 40-47:段属性
4. 48-51:段界限
5. 52-55:段属性
6. 56-63:段基址

详情可见[osdev的gdt描述](https://wiki.osdev.org/Global_Descriptor_Table)

例如下面给出了一段gdt的描述
```c
uint16_t gdt_table[][4] = {
    {0, 0, 0, 0},
    {0xFFFF, 0x0000, 0x9A00, 0x00CF},
    {0xFFFF, 0x0000, 0x9200, 0x00CF},
};
```
由于第一行不可用，因此全置为0，从第二行开始表示代码码，第三行表示数据段，其中的9A和92是描述段的属性。前16位为段界限，也就是0xffff，2^16=64K，然后是20位的段基址，也就是第二个双字和第三个双字的低字节位，都是0表示段基址都是0，最后是段属性CF和最后一个段基址，也是0.

在保护模式下段寄存器中储存的是段选择子，但段选择子中储存的并不全是段在gdt中的下标，段选择子第0和1位储存的是CPL(当前的特权级)，第2位储存的是TI(0表示GDT，1表示LDT)，因此第3位才是段在gdt中的下标。因此对于上面代码中描述的gdt，如果要索引第1行，也就是代码段(9A)，段选择子的值应该为二进制1000,也就是0x8h，而数据段(92)则是10000，也就是0x16h

由于gdt一行就占有8个字节，因此其肯定是储存在内存中的，为了能够随时对gdt进行访问，cpu就专门用一个gdtr的寄存器来储存，使用汇编指令ldgt来加载gdt。ldgt指令的参数是一个结构体指针，而最终gdtr就储存了这个结构体指针的值，也就是保存了gdt描述结构的内存地址。cpu在访问gdt时，会先通过gdtr的值找到gdt描述结构的内存地址，读出描述结构，然后再根据gdt的描述结构再去找gdt。下面的代码描述了lgdt的使用
```c
void lgdt(uint32_t start, uint32_t size) {
    struct {
        uint16_t limit;
        uint16_t start15_0;
        uint16_t start31_15;
    } gdt;

    gdt.start31_15 = start >> 16;
    gdt.start15_0 = start & 0xffff;
    gdt.limit = size - 1;
    __asm__ __volatile__("lgdt %[g]"::[g]"m"(gdt));
}
```

## 从实模式进入保护模式
进入保护模式一共分为5步，分别是：

1. 使用cli指令禁用所有中断
2. 打开A20地址线
3. 加载gdt
4. 打开cr0使能位
5. 长跳转到32位的代码段，以清空流水线

其代码如下:
```c
     // 1. close interrupt
    cli();
    // 2. open A20
    uint8_t v = inb(0x92);
    outb(0x92, v | 0x02);
    // 3. load gdt
    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
    // 4. open cr0
    uint32_t cr0 = read_cr0();
    write_cr0(cr0 | 1);
    // 5. jmp far to clean pipeline
    jmp_far(8, (uint32_t)protect_mode_entry);
```

其中A20是为了让后续的cpu兼容8086寻址的，因为在后续的cpu中可访问的内存大于0x100000的内存，会使用访问，而8086的程序需要在访问大于1M的内存时取0x10000取模，因此使用A20,也就是键盘控制器上剩余的一些输出线来管理第21根地址线。当A20打开时，表示可直接使用大于1M的内存，而关闭时则表示兼容8086，会对0x10000进行取模

在jmp_far时，其实已经进入到保护模式了，因此使用远跳时，指定段选择子8，跳转到gdt中定义的代码段protect_mode_entry中，在protect_mode_entry中即可发现代码段选择器cs已经变成了0x8，也就是段选择子的值。