# 内存分页管理

## 内存分段管理
在[从实模式到保护模式](../loader/protected_mode.md)一文中讲到在实模式下内存真实地址addr=ds<<4 + offset，且这个操作由cpu完成。这样通过直接在段寄存器中传入值的方式，直接访问了真实物理地址，可能实模式的名称也由此得来；保护模式是为了内存安全，预先在gdt中定义各种段，且各个段都可以设置访问权限，以此来避免直接用段寄存器来访问内存可能造成的不安全性问题。

启动了gdt的内存分段管理后，所有的段寄存器中将保存段选择子，也就是这个段在gdt中的index，在内存访问时，通过段选择子先在gdt中找到对应的段描述，然后再通过段描述再找到段基址、段界限以及段权限，以此来判断该段是否可访问，其真实的物理内存地址在哪里。

## 内存分页管理
使用分段管理可以解决段访问安全的问题，但现代操作系统几乎都支持多任务，这就要求每个任务启动时就分配好段，且每个任务的段不能重叠。这些任务的内存申请和释放都是动态的，如果任务创建时就一次性申请所需的所有内存，且任务结束才再一次性全部释放，则内存会被一直占用，任务多了就会很容易导致内存不足，这样也会导致多任务的并发性/并行性降低。同时由于分段的内存块一般比较大，而且分配和释放是在任务开始和结束时进行的，因此容易产生内存碎片，这些内存碎片分布在物理内存的已用内存之间，无法被回收整理到一起。比如分段使用后生产了1M(release)、3M(use)、1M(release)、4M(use)、2M(unuse)，这时如果新任务需要3M的内存，虽然物理内存还有4M可用，但由于内存以碎片方式存在，无法找到连续的3M内存，因此新任务无法找到足够内存，必须等到其他任务结束后释放内存以产生足够的连续内存。

计算机软件解决问题的常用方式就是当前不够用就再虚拟一层，内存的分页管理其实就是在分段的基础上对内存再虚拟一层，将内存切成4k大小的小块，内存访问先基于段取得页表的地址，再从页中取得对应的4k内存块基址，最后在4k内存块中通过offset找到真实的内存地址

如果内存一共有4g，页表的每一项储存4k内存块的基址，页表每一项是4个字节，则一共需要4g/4k=2^20个4字节，也就是4MB。这样的4MB页表可以理解成一个非常大的数组，而数组是连续的。但分页的一个目的就是打破分段管理这种连续内存的规则，让不同的任务不用感知连续的真实内存，而只感知虚拟的连续内存，这些虚拟内存映射到真实内存时不必是连续的。再用到计算机软件解决问题的常用方式，一层虚拟不够就再加一层虚拟，也就是用两级甚至多级页表。比如一级页表中每项储存二级页表的起始地址，让二级页表的每项储存对应的真正内存的起始地址，这样在分页寻址的时候让前10位表示在一级页表中的索引，蹭10位表示在二级页表中的索引，最后12位表示在4k内存块中的offset。如此设计一级表中最多有2^10也就是1024个表项，可以指向1024个二级表，每个二级表又可以有1024个表项，每个表项表示4K的真实内存，因此一共还是1024*1024*4K=4G内存。

二级页表的好处是在内存未分配时，可以不用创建二级页表，此时一级页表项中还是零值。此时的一级页表称为目录表。

## 开启分页
在[从实模式到保护模式](../loader/protected_mode.md)中已经讲述通过构造gdt，将gdt通过ldgt指令加载以实现保护模式下的分段。分页的实现也类似，需要先构造页表，再将页表地址保存到cr4寄存器。
```c
    // 设置PSE，以便启用4M的页，而不是4KB
    uint32_t cr4 = read_cr4();
    write_cr4(cr4 | CR4_PSE);

    // 设置页表地址
    write_cr3((uint32_t)page_dir);

    // 开启分页机制
    write_cr0(read_cr0() | CR0_PG);
```

由于要使用二级页表，因此需要在目录表项中标识这个表项指向的是一个二级页而不是真实的4K内存起始地址。

在目录表和二级页表中的表项均用32位储存，其中目录页的高20位储存二级页表的起始地址，低12位储存表项属性，其中就用第7位表示是否指向二级页，如果是0表示默认指向二级页，如果是1表示直接指向4M的内存地址，因此可以用这种方式在目录页中生成一个4M的内存页。这里4M的页的存在意义在于开启分页模式之前的代码运行在未分页模式下，各种变量保存的是真实的物理地址，如果全部内存都分页了，将会导致这些变量无法再找到原来的物理地址，造成错误的虚拟地址->真实物理地址的映射，因此保留了0~4M的虚拟内存直接映射到0~4M的物理内存地址。

## 构造目录表和页表
对照上面的开启分页的代码，实现page_dir的结构
```c
#define PDE_P (1 << 0)
#define PDE_PS (1 << 7)
#define PDE_W (1 << 1)
#define PDE_U (1 << 2)
#define CR4_PSE (1 << 4)
#define CR0_PG (1 << 31)
    // 使用4MB页块，这样构造页表就简单很多，只需要1个表即可。
    // 以下表为临时使用，用于帮助内核正常运行，在内核运行起来之后，将重新设置
    static uint32_t page_dir[1024] __attribute__((aligned(KB(4)))) = {
        [0] = PDE_P | PDE_PS | PDE_W,  // PDE_PS，开启4MB的页
    };
```
上面代码中：
1. PDE_P也就是属性区的第0位表示此表项是否启用，未启动表示未分配内存；
2. PDE_PS也就是第7位表示此表示是否指向4M的内存
3. PDE_W也就是第1位表示此块内存是否可写
4. PDE_U表示是否是用户级内存，否则是系统级内存，需要高级权限才可访问

按之前所说，需要先直接映射0~4M的虚拟内存到物理内存，因此目录页的第0个表项中储存的地址未写，就是0，属性中有PDE_PS表示指向4M的内存地址。为了演示二级页表可用，在开启分页模式后，再在目录表中添加一个表项，指向一个二级页表，在二级页表中写入一个数据，最后再用指针直接访问这个虚拟地址。
```c
#define MAP_ADDR 0x80000000
uint8_t map_pyh_buff[KB(4)] __attribute__((aligned(KB(4)))) = {0x36};

void set_page() {
    static uint32_t page_dir2[KB(1)] __attribute__((aligned(KB(4)))) = {0};

    page_dir2[MAP_ADDR >> 12 & 0x3ff] =
        (uint32_t)map_pyh_buff | PDE_P | PDE_W | PDE_U;

    uint32_t *page_dir = (uint32_t *)read_cr3();
    page_dir[MAP_ADDR >> 22] = (uint32_t)page_dir2 | PDE_P | PDE_W | PDE_U;
}
```
上面的代码定义了map_pyh_buff的4K大小数组，写入0x36，对应10进制的54。在set_page中又定义了一个二级表，这个二级表按前面描述的，第个表项都是32位，一共1024个表项。我们要写入的虚拟地址是MAP_ADDR，将其右移12位得到高20位，高20位与0x3ff(1111111111)做位与运算，得到中间10位，这10位就是虚拟内存在二级页表中的索引，因此用page_dir2取这个索引，在这个页表项中写入map_pyh_buff这个物理内存地址。最后再从cr3中读出目录表的地址，用同样的方式将MAP_ADDR右移22位得到高10位，也就是其在目录表中的索引，将此索引的表项中写入二级表的地址，并且添加上属性值，这时的属性值没有PDE_PS，也就是使用了默认值0，表示这个目录表项指向的是一个二级表而不是一块4M的内存。

```c
void main() {
    uint32_t a = 10;
    uint32_t *p = &a;
    set_page();
    p = (uint32_t*)0x80000000;
    uint32_t value = *p;
    for (;;) {
    }
}
```
最后用一个32位的指针变量直接指向MAP_ADDR这块虚拟内存，取出这个虚拟内存对应的真实物理内存中保存的值，可以发现这个值就是之前写入的map_pyh_buff中的0x36，这样也就验证了内存分页管理已经正常开启，并且二级页表可用。

## 分布管理寻址快表
经过上面的分析，开启二级分页内存管理后，内存寻址就变成了段页式。指定一个内存地址，需要以下几步：
1. 先从cr3中取出目录表的地址，结束段寄存器中保存的数据段，找到目录表的真实物理地址。
2. 根据虚拟内存地址的高10位找到对应的目录表项，如果指向的是一个4M物理内存，则直接进行寻址
3. 在目录表项中指向的是一个二级页表，则取出表项中的二级页表地址，找到这个二级页表，取出虚拟地址的中间10位，在二级页表中根据这中间10位找到对应的物理内存页起始地址
4. 虚拟内存地址的低12位表示在4K内存页中的偏移，从二级页表项中取出4K内存页的起始地址，与虚拟内存地址的低12位相加，得到真实的物理内存，再用实模式下的内存寻址方式，找到内存进行取值。
   
上面的4步进行了三次内存访问，这样进行一次分页模式下的内存访问，实际上却进行了三次物理内存寻址，虽然提供了方便和灵活，但降低了性能。

由于内存访问具有局部性的特性，因此可以使用缓存的方式来解决频繁重复物理寻址的性能问题，这个缓存叫作TLB(Translation Lookaside Buff)。由于这里的三次寻址已经是在内存中了，因此这个缓存肯定不在内存中。比内存更快的只有cpu了，因此将这个缓存保存在cpu中，cpu的储存是最昂贵的，因此这个缓存肯定特别小。为了避免缓存经常失败，因此TLB采用了一些缓存算法，解决局部性原理问题。tlb中跟页表一样，保存了虚拟内存到物理内存的映射，由于采用了二级页表，因此需要用20位保存表项索引，这个索引对应着4K物理内存页，当然也还需要保存一些内存页的属性，比如此页是否被使用。当进行虚拟内存的访问时，就可以先访问tlb，如果在tlb中命中缓存，则直接取出缓存的物理内存页地址，与虚拟内存地址的低12位表示的偏移相加得到真实物理地址，这样进行一次寻址即可完成虚拟内存的访问，如果在tlb中找不到，则再用上面的4步法用页表进行三次内存寻址。

在页表更新时，缓存也需要刷新，否则就会形成脏数据，导致内存访问错误。cpu并没有自动管理tlb的刷新，而是把tlb的刷新交给了操作系统，因此页表的修改也是操作系统完成的。tlb的刷新一般有两种方式，一样是重新设置cr3的值，也就是更新cr3中保存的目录表的地址，这样会将tlb的缓存全部刷新；另一种方式是使用cpu提供的`invlpg [addr]`指令，指向addr这个虚拟内存地址的缓存，在操作系统内存管理的实现的中，在进行内存分配和释放，修改页表时，需要通过这个指令来刷新tlb缓存。

在kernel/main.c中的函数test_invlpg中进行了实验
```c
void test_remap() {
    pde_t *page_dir = (pde_t *)read_cr3();
    ASSERT(page_dir != (pde_t *)0);
    pte_t *pte = find_pte(page_dir, 0x80001000, 0);
    ASSERT(pte != (pte_t *)0);
    uint32_t phy_addr;
    int err = get_phy_addr(0x80001000, &phy_addr, 0);
    ASSERT(err == 0);
    pte = find_pte(page_dir, 0x80000000, 0);
    pte->v = phy_addr | (1 << 0) | (1 << 1) | (1 << 2);
}
void test_invlpg() {
    test_remap();
    uint32_t *p = (uint32_t *)0x80000000;
    uint32_t value = *p;

    __asm__ __volatile__("invlpg (%[v])" ::[v] "r"(0x80000000));
    value = *p;
}
```
在前面将虚拟内存0x80000000和0x80001000的值分别设置成了0x12和0x13，在test_invlpg函数中先取得0x80001000对应的物理地址，再将0x80000000与这个物理地址进行映射。然后取虚拟内存0x80000000中的值，这时发现取得的值还是0x12，表示将0x80000000映射到0x80001000的物理地址没有生效，取得的值还是重新映射之前的。

使用invlpg指令后，再重新取虚拟内存0x80000000中的值，这时发现已经变成了0x13，是重新映射之后物理内存中的值。因此可以证明，pte重新映射后，马上用虚拟内存进行访问其实访问的是tlb中的缓存，只有用invlpg指令disable tlb缓存中的对应虚拟内存地址后，才能让重新映射的值更新到tlb中。

接着，使用write_cr3重新加载pde试试：
```c
void test_reload_paing() {
    test_remap();

    uint32_t *p = (uint32_t *)0x80000000;
    uint32_t value = *p;

    pde_t *page_dir = (pde_t *)read_cr3();
    ASSERT(page_dir != (pde_t *)0);
    write_cr3((uint32_t)page_dir);
    value = *p;
}
```
在write_cr3之前，从虚拟内存0x80000000取得的值是0x12，而把pde重新加载到cr3之后，再从虚拟内存0x80000000中取得的值就变成了0x13了，证明使用cr3重新加载pde后，也能达到刷新tlb缓存的效果。